# -*- Tcl -*-

package require tcltest 2.2
namespace import -force ::tcltest::*

::tcltest::configure {*}$argv

tcltest::testConstraint tcl86 [expr {$::tcl_version >= 8.6}]
testConstraint with_deprecated [dict get [ns_info buildinfo] with_deprecated]

#######################################################################################
#  test ns_rand
#######################################################################################
test ns_rand-1.0 {syntax: ns_rand} -body {
    ns_rand 1 x
} -returnCodes error -result {wrong # args: should be "ns_rand ?/maximum[1,MAX]/?"}

test ns_rand-1.1 {ns_rand with 1 arg - integer} -body {
    set rand [ns_rand 10]
    return [list [expr {$rand < 10}] [string is integer -strict $rand] ]
} -result {1 1}

test ns_rand-1.2 {ns_rand with 0 arg - float} -body {
    set rand [ns_rand]
    return [list [expr {$rand < 1}] [string is double -strict $rand] ]
} -result {1 1}

#######################################################################################
#  test ns_parseheader
#######################################################################################
test ns_parseheader-1.0 {syntax: ns_parseheader} -body {
    ns_parseheader
} -returnCodes error -result {wrong # args: should be "ns_parseheader ?-prefix /value/? /set/ /headerline/ ?/disposition/?"}

#######################################################################################
#  test ns_parsemessage
#######################################################################################
test ns_parsemessage-1.0 {syntax: ns_parsemessage} -body {
    ns_parsemessage
} -returnCodes error -result {wrong # args: should be "ns_parsemessage /message/"}

#######################################################################################
#  test ns_fmttime
#######################################################################################

test ns_fmttime-1.0 {syntax: ns_fmttime} -body {
    ns_fmttime
} -returnCodes error -result {wrong # args: should be "ns_fmttime /time[0,MAX]/ ?/fmt/?"}

test ns_fmttime-1.1 {ns_fmttime without format} -body {
    #
    # "ns_fmttime" depends on the local time-zone. Since we cannot
    # pass the timezone as an argument, we make a rough test here.
    #
    return [llength [ns_fmttime 1563812758]]
} -result {5}

test ns_fmttime-1.2 {ns_rand with 0 arg - float} -body {
    #
    # The year information is in all timezones for this timestamp
    # identical.
    #
    return [ns_fmttime 1563812758 "%Y 00:00"]
} -result {2019 00:00}

#######################################################################################
#  test ns_trim
#######################################################################################

test ns_trim-0.0 {syntax: ns_trim} -body {
    ns_trim
} -returnCodes error -result {wrong # args: should be "ns_trim ?-subst? ?-delimiter /value/? ?-prefix /value/? ?--? /text/"}

test ns_trim-0.1 {ns_trim with invalid delimiter} -body {
    ns_trim -delimiter aa "hello world"
} -returnCodes error -result {invalid arguments: -delimiter must be a single character}
test ns_trim-0.2 {ns_trim with delimiter and prefix} -body {
    ns_trim -delimiter a -prefix b "hello world"
} -returnCodes error -result {invalid arguments: either -prefix or -delimiter can be specified}

test ns_trim-1.1 {nothing to trim} -body {
    string map {\n \\n} [ns_trim "line1\nline2"]
} -result {line1\nline2}
test ns_trim-1.2 {trim spaces} -body {
    string map {\n \\n} [ns_trim " line1\n  line2\nline3\n "]
} -result {line1\nline2\nline3}
test ns_trim-1.3 {trim with delimiter} -body {
    string map {\n \\n} [ns_trim -delimiter : " : line1\n  : line2\n    : line3\n :"]
} -result { line1\n line2\n line3\n}
test ns_trim-1.4 {trim with delimiter and leading newline} -body {
    string map {\n \\n} [ns_trim -delimiter : "\n : line1\n  : line2\n    : line3\n :"]
} -result { line1\n line2\n line3\n}
test ns_trim-1.5 {trim with delimiter and no occurrence of delimiter} -body {
    string map {\n \\n} [ns_trim -delimiter ! "\n : line1\n  : line2\n    : line3\n :"]
} -result {: line1\n: line2\n: line3\n:}

test ns_trim-2.1 {trim with prefix} -body {
    string map {\n \\n} [ns_trim -prefix "> " "\n>  line1\nline2\n>   line3\n> "]
} -result {\n line1\nline2\n  line3\n}
test ns_trim-2.2 {trim with delimiter and no occurrence of prefix} -body {
    string map {\n \\n} [ns_trim -prefix > "\n : line1\n  : line2\n    : line3\n :"]
} -result {\n : line1\n  : line2\n    : line3\n :}

#######################################################################################
#  test ns_strcoll
#######################################################################################
testConstraint collateFold [expr {$::tcl_platform(os) in {Darwin Linux}}]
testConstraint collateDash [expr {$::tcl_platform(os) in {Linux}}]
testConstraint localeCollate [expr {$::tcl_platform(os) in {Darwin Linux}}]

test ns_strcoll-1.0 {syntax: ns_strcoll} -body {
    ns_strcoll
} -returnCodes error -result {wrong # args: should be "ns_strcoll ?-locale /value/? ?--? /string1/ /string2/"}

#
# The constraint 'collateFold' means to sort upper and lower character
# right next to each other and to ignore certain characters
# (e.g. dash) in the sorting order when comparing UTF-8. Probably,
# strcoll_l on these systems is based on the ICU library
# (International Components for Unicode).
#
test ns_strcoll-1.2 {ns_strcoll without locale (assuming en_US.UTF-8)} \
    -constraints localeCollate -body {
        return [expr {[ns_strcoll Bär Bor] < 0}]
    } -result 1

test ns_strcoll-1.3 {ns_strcoll with locale C} \
    -body {
        return [expr {[ns_strcoll -locale C Bär Bor] > 0}]
    } -result 1

test ns_strcoll-1.4 {ns_strcoll with locale en_US.UTF-8 } \
    -constraints localeCollate -body {
        return [expr {[ns_strcoll -locale en_US.UTF-8 Bär Bor] < 0}]
    } -result 1

test ns_strcoll-1.5 {ns_strcoll without locale specified} \
    -constraints localeCollate -body {
        set l {Önce Ince Once Ance Adam Çengel Art Ceb Dora Pravda Правда Omikron ό Zeppelin Bar Bor Bär}
        return [lsort -command ns_strcoll $l]
    } -match glob -result {*Adam Ance Art Bar Bär Bor Ceb Çengel Dora Ince Omikron Once Önce Pravda Zeppelin*}
#
# For macOS Seqouia 15.4, the collating order of cyrillc characters
# changed. New they are in front, before they were at the end. See:
# -result {Adam Ance Art Bar Bär Bor Ceb Çengel Dora Ince Omikron Once Önce Pravda Zeppelin ό Правда}

test ns_strcoll-1.6 {ns_strcoll with locale en_US.UTF-8} \
    -constraints localeCollate -body {
        set l {Önce Ince Once Ance Adam Çengel Art Ceb Dora Pravda Правда Omikron ό Zeppelin Bar Bor Bär}
        return [lsort -command {ns_strcoll -locale en_US.UTF-8 --} $l]
    } -match glob -result {*Adam Ance Art Bar Bär Bor Ceb Çengel Dora Ince Omikron Once Önce Pravda Zeppelin*}
# -result {Adam Ance Art Bar Bär Bor Ceb Çengel Dora Ince Omikron Once Önce Pravda Zeppelin ό Правда}

#
# Check ignored dashes
#
test ns_strcoll-2.1 {sort with leading dashes, without locale specified} \
    -constraints {collateDash} -body {
        set l {b 1 -a}
        return [lsort -command ns_strcoll $l]
    } -result {1 -a b}

test ns_strcoll-2.2 {sort with leading dashes, with locale en_US.UTF-8} \
    -constraints {collateDash} -body {
        set l {b 1 -a}
        return [lsort -command {ns_strcoll -locale en_US.UTF-8 --} $l]
    } -result {1 -a b}

test ns_strcoll-2.3 {sort with leading dashes, with locale C} \
    -body {
        set l {b 1 -a}
        return [lsort -command {ns_strcoll -locale C --} $l]
    } -result {-a 1 b}

#
# Check case sorting
#
test ns_strcoll-3.1 {sort with upper and lowercase characters, no locale} \
    -constraints {collateFold} -body {
        set l {za zb Za ma mb Ma aa ab Aa 1 .}
        return [lsort -command ns_strcoll $l]
    } -result {. 1 aa Aa ab ma Ma mb za Za zb}

test ns_strcoll-3.2 {sort with upper and lowercase characters, locale en_US.UTF-8} \
    -constraints {collateFold} -body {
        set l {za zb Za ma mb Ma aa ab Aa 1 .}
        return [lsort -command {ns_strcoll -locale en_US.UTF-8 --} $l]
    } -result {. 1 aa Aa ab ma Ma mb za Za zb}

test ns_strcoll-3.3 {sort with upper and lowercase characters, locale C} \
    -body {
        set l {za zb Za ma mb Ma aa ab Aa 1 .}
        return [lsort -command {ns_strcoll -locale C --} $l]
    } -result {. 1 Aa Ma Za aa ab ma mb za zb}

#######################################################################################
#  test ns_valid_utf8
#######################################################################################

test ns_valid_utf8-1.0 {syntax: ns_valid_utf8} -body {
    ns_valid_utf8 - - -
} -returnCodes error -result {wrong # args: should be "ns_valid_utf8 /string/ ?/varname/?"}

test ns_valid_utf8-1.1 {ns_valid_utf8 with typical value} -body {
    return [ns_valid_utf8 "hello world"]
} -result 1

test ns_valid_utf8-1.2 {invalid utf8, containing x85 at the end} -body {
    return [ns_valid_utf8 "forschungsprojek\x85"]
} -result 0

test ns_valid_utf8-1.3 {valid utf8, containing x85 at the end} -body {
    return [ns_valid_utf8 "forschungsprojek\xc3\x85"]
} -result 1

test ns_valid_utf8-1.4 {invalid utf8, containing xF0 at the end} -body {
    ns_valid_utf8 "forschungsprojek\xF0" errorString; set errorString
} -result {forschungs...|\xf0|}

test ns_valid_utf8-1.5 {invalid utf8, containing x85 in the middle} -body {
    ns_valid_utf8 "mot\x85rhead" errorString; set errorString
} -result {mot|\x85r|...}

test ns_valid_utf8-2.0 {invalid utf8, lone continuation byte} -body {
    ns_valid_utf8 "\x80" errorString; set errorString
} -result {|\x80|}

test ns_valid_utf8-2.1 {invalid utf8, lone continuation byte at the start} -body {
    ns_valid_utf8 "\x80hello" errorString; set errorString
} -result {|\x80h|...}

test ns_valid_utf8-2.2 {invalid utf8, lone continuation byte at the end} -body {
    ns_valid_utf8 "hello\x80" errorString; set errorString
} -result {hello|\x80|}

test ns_valid_utf8-2.3 {invalid utf8, lone continuation byte in the middle} -body {
    ns_valid_utf8 "hello\x80world" errorString; set errorString
} -result {hello|\x80w|...}

test ns_valid_utf8-3.0 {invalid utf8, too few continuation bytes} -body {
    ns_valid_utf8 "\xE2\x82" errorString; set errorString
} -result {|\xe2\x82|}

test ns_valid_utf8-3.1 {invalid utf8, too few continuation bytes at the start} -body {
    ns_valid_utf8 "\xE2\x82hello" errorString; set errorString
} -result {|\xe2\x82h|...}

test ns_valid_utf8-3.2 {invalid utf8, too few continuation bytes at the end} -body {
    ns_valid_utf8 "hello\xE2\x82" errorString; set errorString
} -result {hello|\xe2\x82|}

test ns_valid_utf8-3.3 {invalid utf8, too few continuation bytes in the middle} -body {
    ns_valid_utf8 "hello\xE2\x82world" errorString; set errorString
} -result {hello|\xe2\x82w|...}


test ns_valid_utf8-4.0 {3-byte utf8, invalid 2nd byte} -body {
    ns_valid_utf8 "\xE2_\xA1" errorString; set errorString
} -result {|\xe2_\xa1|...}

test ns_valid_utf8-4.1 {3-byte utf8, invalid continuation byte at the start} -body {
    ns_valid_utf8 "\xE2_\xA1hello" errorString; set errorString
} -result {|\xe2_\xa1|...}

test ns_valid_utf8-4.2 {3-byte utf8, invalid continuation byte at the end} -body {
    ns_valid_utf8 "hello\xE2_\xA1" errorString; set errorString
} -result {hello|\xe2_\xa1|...}

test ns_valid_utf8-4.3 {3-byte utf8, invalid continuation byte in the middle} -body {
    ns_valid_utf8 "hello\xE2_\xA1world" errorString; set errorString
} -result {hello|\xe2_\xa1|...}


test ns_valid_utf8-5.0 {invalid utf8, invalid leading byte} -body {
    ns_valid_utf8 "\xBF\xA3" errorString; set errorString
} -result {|\xbf\xa3|...}

test ns_valid_utf8-5.1 {invalid utf8, invalid leading byte at the start} -body {
    ns_valid_utf8 "\xBF\xA3hello" errorString; set errorString
} -result {|\xbf\xa3|...}

test ns_valid_utf8-5.2 {invalid utf8, invalid leading byte at the end} -body {
    ns_valid_utf8 "hello\xBF\xA3" errorString; set errorString
} -result {hello|\xbf\xa3|...}

test ns_valid_utf8-5.3 {invalid utf8, invalid leading byte in the middle} -body {
    ns_valid_utf8 "hello\xBF\xA3world" errorString; set errorString
} -result {hello|\xbf\xa3|...}


test ns_valid_utf8-6.0 {invalid 4-byte utf8, out of range code point} -body {
    ns_valid_utf8 "\xF8\x80\x80\x80\x80" errorString; set errorString
} -result {|\xf8\x80\x80\x80|...}

test ns_valid_utf8-6.1 {invalid 4-byte utf8, out of range code point at the start} -body {
    ns_valid_utf8 "\xF8\x80\x80\x80\x80hello" errorString; set errorString
} -result {|\xf8\x80\x80\x80|...}

test ns_valid_utf8-6.2 {invalid 4-byte utf8, out of range code point at the end} -body {
    ns_valid_utf8 "hello\xF8\x80\x80\x80\x80" errorString; set errorString
} -result {hello|\xf8\x80\x80\x80|...}

test ns_valid_utf8-6.3 {invalid 4-byte utf8, out of range code point in the middle} -body {
    ns_valid_utf8 "hello\xF8\x80\x80\x80\x80world" errorString; set errorString
} -result {hello|\xf8\x80\x80\x80|...}


test ns_valid_utf8-7.0 {invalid utf8, surrogate halves} -body {
    ns_valid_utf8 "\xED\xA0\x80" errorString; set errorString
} -result {|\xed\xa0\x80|...}

test ns_valid_utf8-7.1 {invalid utf8, surrogate halves at the start} -body {
    ns_valid_utf8 "\xED\xA0\x80hello" errorString; set errorString
} -result {|\xed\xa0\x80|...}

test ns_valid_utf8-7.2 {invalid utf8, surrogate halves at the end} -body {
    ns_valid_utf8 "hello\xED\xA0\x80" errorString; set errorString
} -result {hello|\xed\xa0\x80|...}

test ns_valid_utf8-7.3 {invalid utf8, surrogate halves in the middle} -body {
    ns_valid_utf8 "hello\xED\xA0\x80world" errorString; set errorString
} -result {hello|\xed\xa0\x80|...}


test ns_valid_utf8-8.0 {invalid utf8, overlong encoding} -body {
    ns_valid_utf8 "\xC0\xAF" errorString; set errorString
} -result {|\xc0\xaf|...}

test ns_valid_utf8-8.1 {invalid utf8, overlong encoding at the start} -body {
    ns_valid_utf8 "\xC0\xAFhello" errorString; set errorString
} -result {|\xc0\xaf|...}

test ns_valid_utf8-8.2 {invalid utf8, overlong encoding at the end} -body {
    ns_valid_utf8 "hello\xC0\xAF" errorString; set errorString
} -result {hello|\xc0\xaf|...}

test ns_valid_utf8-8.3 {invalid utf8, overlong encoding in the middle} -body {
    ns_valid_utf8 "hello\xC0\xAFworld" errorString; set errorString
} -result {hello|\xc0\xaf|...}


#######################################################################################
#  test ns_ip
#######################################################################################

test ns_ip-1.0.1 {syntax: ns_ip} -body {
    ns_ip
} -returnCodes error -result {wrong # args: should be "ns_ip inany|match|properties|public|trusted|valid ?/arg .../"}

test ns_ip-1.0.2 {syntax: ns_ip subcommand} -body {
    ns_ip x
} -returnCodes error -result {ns_ip: bad subcommand "x": must be inany, match, properties, public, trusted, or valid}

test ns_ip-1.1.0 {syntax: ns_ip match} -body {
    ns_ip match
} -returnCodes error -result {wrong # args: should be "ns_ip match /cidr/ /ipaddr/"}
test ns_ip-1.1.1 {syntax: ns_ip properties} -body {
    ns_ip properties
} -returnCodes error -result {wrong # args: should be "ns_ip properties /ipaddr/"}
test ns_ip-1.1.2 {syntax: ns_ip public} -body {
    ns_ip public
} -returnCodes error -result {wrong # args: should be "ns_ip public /ipaddr/"}
test ns_ip-1.1.3 {syntax: ns_ip trusted} -body {
    ns_ip trusted
} -returnCodes error -result {wrong # args: should be "ns_ip trusted /ipaddr/"}
test ns_ip-1.1.4 {syntax: ns_ip valid} -body {
    ns_ip valid
} -returnCodes error -result {wrong # args: should be "ns_ip valid ?-type ipv4|ipv6? ?--? /ipaddr/"}
test ns_ip-1.1.5 {syntax: ns_ip inany} -body {
    ns_ip inany
} -returnCodes error -result {wrong # args: should be "ns_ip inany /ipaddr/"}


test ns_ip-1.2.1 {ns_ip properties particular address} -body {
   ns_ip properties 127.0.0.1
} -match glob -result {public 0 trusted [01] inany [01] type IPv4}

test ns_ip-1.3.1 {ns_ip inany} -body {
    lmap ip {192.168.64.1 127.0.0.1 ::1 :: 0.0.0.0 137.208.116.31 2001:628:404:74::31} {ns_ip inany $ip}
} -returnCodes {error ok} -result {0 0 0 1 1 0 0}

test ns_ip-1.3.2 {ns_ip public} -body {
    lmap ip {192.168.64.1 127.0.0.1 ::1 0.0.0.0 ::
        137.208.116.31 2001:628:404:74::31} {ns_ip public $ip}
} -result {0 0 0 0 0 1 1}

test ns_ip-1.3.3 {ns_ip trusted} -body {
    lmap ip {137.208.116.31 2001:628:404:74::31} {ns_ip trusted $ip}
} -result {0 0}

test ns_ip-1.3.4 {ns_ip valid} -body {
    lmap ip {192.168.64.1 127.0.0.1 ::1 0.0.0.0 :: 137.208.116.31 2001:628:404:74::31
        1.1.1.1.1 openacs.org } {ns_ip valid $ip}
} -result {1 1 1 1 1 1 1 0 0}


#
#  test ns_ip match
#
test ns_ip_match--1.0 {ns_ip match IPv4} -body {
    return [ns_ip match 137.208.0.0/16 137.208.116.31]
} -result 1

test ns_ip_match--1.1 {ns_ip match IPv4 invalid cidr} -body {
    ns_ip match 137.208/16 137.208.116.31
} -returnCodes error  -result {'137.208/16' is not a valid CIDR string for IPv4 or IPv6}
test ns_ip_match--1.2 {ns_ip match IPv4 invalid ip} -body {
    ns_ip match 137.208.0.0/16 137.208.116
} -returnCodes error  -result {'137.208.116' is not a valid IPv4 or IPv6 address}

test ns_ip_match--1.3 {ns_ip match IPv4} -body {
    lmap ip {
        137.208.215.0
        137.208.216.0
        137.208.219.0
        137.208.220.0
        137.208.223.0
        137.208.224.0
    } {ns_ip match 137.208.216.0/21 $ip}
} -result {0 1 1 1 1 0}

test ns_ip_match--1.4 {ns_ip match IPv4} -body {
    lmap ip {
        137.208.215.0
        137.208.216.0
        137.208.219.0
        137.208.220.0
        137.208.223.0
        137.208.224.0
    } {ns_ip match 0.0.0.0/0 $ip}
} -result {1 1 1 1 1 1}

test ns_ip_match--2.0 {ns_ip match IPv6} -body {
    return [ns_ip match 2001:4860:4860::8888/32 2001:4860:6666:6666:6666:6666:6666:66FF]
} -result 1

test ns_ip_match--2.1 {ns_ip match IPv6 invalid cidr} -body {
    ns_ip match 2001:4860:4860:8888/32 2001:4860:6666:6666:6666:6666:6666:66FF
} -returnCodes error  -result {'2001:4860:4860:8888/32' is not a valid CIDR string for IPv4 or IPv6}

test ns_ip_match--2.2 {ns_ip match IPv6 invalid ip} -body {
    ns_ip match 2001:4860:4860::8888/32 2001:4860:6666:6666:6666:6666:6666
} -returnCodes error  -result {'2001:4860:6666:6666:6666:6666:6666' is not a valid IPv4 or IPv6 address}

test ns_ip_match--2.3 {ns_ip match comparing IPv4 with IPv6} -body {
    ns_ip match 2001:628:404:74::31/64 137.206.1.1
} -result 0

test ns_ip_match--2.4 {ns_ip match IPv4} -body {
    lmap ip {
        2001:628:404:74::31
        ::1
        ::0
    } {ns_ip match ::/0 $ip}
} -result {1 1 1}


#######################################################################################
#  test ns_rlimit
#######################################################################################

test ns_rlimit-1.0 {ns_rlimit general} -body {
    ns_rlimit
} -returnCodes error -result {wrong # args: should be "ns_rlimit /subcommand/ ?/arg .../?"}

test ns_rlimit-1.1 {ns_rlimit wrong subcommand} -body {
    ns_rlimit ?
} -returnCodes error -result {bad subcommand "?": must be coresize, datasize, files, filesize, or vmsize}

test ns_rlimit-1.2 {syntax: ns_rlimit coresize} -body {
    ns_rlimit coresize 1 ?
} -returnCodes error -result {wrong # args: should be "ns_rlimit coresize ?/value/?"}

test ns_rlimit-1.3 {syntax: ns_rlimit datasize} -body {
    ns_rlimit datasize 1 ?
} -returnCodes error -result {wrong # args: should be "ns_rlimit datasize ?/value/?"}

test ns_rlimit-1.4 {syntax: ns_rlimit files} -body {
    ns_rlimit files 1 ?
} -returnCodes error -result {wrong # args: should be "ns_rlimit files ?/value/?"}

test ns_rlimit-1.5 {syntax: ns_rlimit filesize} -body {
    ns_rlimit filesize 1 ?
} -returnCodes error -result {wrong # args: should be "ns_rlimit filesize ?/value/?"}

test ns_rlimit-1.6 {syntax: ns_rlimit vmsize} -body {
    ns_rlimit vmsize 1 ?
} -returnCodes error -result {wrong # args: should be "ns_rlimit vmsize ?/value/?"}

#######################################################################################
#  ns_baseunit
#######################################################################################

test ns_baseunit-1.0 {syntax: ns_baseunit} -body {
    ns_baseunit ?
} -returnCodes error -result {wrong # args: should be "ns_baseunit ?-size /memory-size/? ?-time /time/?"}

#######################################################################################
#  ns_setprivileges
#######################################################################################

test ns_setgroup-1.0 {syntax: ns_setgroup} -body {
    ns_setgroup
} -returnCodes error -result {wrong # args: should be "ns_setgroup /group/"}

test ns_setuser-1.0 {syntax: ns_setuser} -body {
    ns_setuser
} -returnCodes error -result {wrong # args: should be "ns_setuser /user/"}

#######################################################################################
#  Other commands, in part defined in Tcl
#######################################################################################

test ns_browsermatch-1.0 {syntax: ns_hash} -constraints with_deprecated -body {
    ns_browsermatch
} -returnCodes error -result {wrong # args: should be "ns_browsermatch pattern"}
# ns_browsermatch is a Tcl proc: message should be {wrong # args: should be "ns_browsermatch /pattern/"}

test ns_htmlselect-1.0 {syntax: ns_htmlselect} -body {
    ns_htmlselect
} -match glob -result {*<select name=*}
# "ns_htmlselect" is a Tcl proc: message should be {wrong # args: should be "ns_htmlselect ?-multi? ?-sort? ?-labels /labels/? /name/ /values/ ?/selectedData/?"}


test ns_hash-1.0 {syntax: ns_hash} -body {
    ns_hash
} -returnCodes error -result {wrong # args: should be "ns_hash /value/"}

test ns_crash-1.0 {syntax: ns_crash} -body {
    ns_crash ?
} -returnCodes error -result {wrong # args: should be "ns_crash"}

test ns_urlcharset-1.0 {syntax: ns_urlcharset} -body {
    ns_urlcharset
} -returnCodes error -result {wrong # args: should be "ns_urlcharset charset"}

# ns_urlcharset is a Tcl proc: message should be {wrong # args: should be "ns_urlcharset /charset/"}

test ns_issmallint-1.0 {syntax: ns_issmallint} -body {
    ns_issmallint
} -returnCodes error -result {wrong # args: should be "ns_issmallint value"}
# ns_issmallint is a Tcl proc: message should be {wrong # args: should be "ns_issmallint /value/"}

test ns_paren-1.0 {syntax: ns_paren} -constraints with_deprecated -body {
    ns_paren x y
} -returnCodes error -result {wrong # args: should be "ns_paren val"}
# ns_paren is a Tcl proc: message should be {wrong # args: should be "ns_paren /value/"}


test ns_setexpires-1.0 {syntax: ns_setexpires} -body {
    ns_setexpires x y
} -returnCodes error -result {usage: ns_setexpires ?-cache-control public|private|no-cache|no-store|no-transform|must-revalidate|proxy-revalidate? seconds}
# ns_setexpires is a Tcl proc: message should be {wrong # args: should be "ns_setexpires ?-cache-control public|private|no-cache|no-store|no-transform|must-revalidate|proxy-revalidate? /seconds/"}

test ns_tagelement-1.0 {syntax: ns_tagelement} -constraints with_deprecated -body {
    ns_tagelement
} -returnCodes error -result {wrong # args: should be "ns_tagelement tag key"}
# ns_tagelement is a Tcl proc: message should be {wrong # args: should be "ns_tagelement /tag/ /attribute/"}

test ns_tagelementset-1.0 {syntax: ns_tagelement} -constraints with_deprecated -body {
    ns_tagelementset
} -returnCodes error -result {wrong # args: should be "ns_tagelementset tagvar key value"}
# ns_tagelementset is a Tcl proc: message should be {wrong # args: should be "ns_tagelementset /tagvar/ /attribute/ /value/"}

test ns_cookiecharset-1.0 {syntax: ns_cookiecharset} -constraints with_deprecated -body {
    ns_cookiecharset
} -returnCodes error -result {wrong # args: should be "ns_cookiecharset name"}

# ns_cookiecharset is a Tcl proc: message should be {wrong # args: should be "ns_cookiecharset /name/"}

test ns_choosecharset-1.0 {syntax: ns_choosecharset} -constraints with_deprecated -body {
    ns_choosecharset x
} -returnCodes error -result {Usage: ns_choosecharset ?-preference charset-list?}

# ns_choosecharset is a Tcl proc: message should be {wrong # args: should be "ns_choosecharset ?-preference /charset-list/?"}

test ns_formfieldcharset-1.0 {syntax: ns_formfieldcharset} -constraints with_deprecated -body {
    ns_formfieldcharset
} -returnCodes error -result {wrong # args: should be "ns_formfieldcharset name"}

# ns_formfieldcharset is a Tcl proc: message should be {wrong # args: should be "ns_formfieldcharset /name/"}

test ns_sendmail_config-1.0 {syntax: ns_sendmail_config} -body {
    ns_sendmail_config ? ?
} -returnCodes error -result {wrong # args: should be "ns_sendmail_config ?mode?"}
# should be  {wrong # args: should be "ns_sendmail_config ?log?"}

test ns_sendmail-1.0 {syntax: ns_sendmail} -body {
    ns_sendmail -? ?
} -returnCodes error -result {wrong # args: should be "?-to /to/? ?-from /from/? ?-subject /subject/? ?-body /body/? ?-headers /headers/? ?-bcc /bcc/? ?-cc /cc/?"}
# ns_sendmail is a Tcl proc: message should be {wrong # args: should be "ns_sendmail -to /value/ -from /value/ ?-subject /value/? ?-body /value/? ?-headers /value/? ?-bcc /value/? ?-cc /value/?"}

#######################################################################################
#  test ns_parsemessage
#######################################################################################

test ns_parsemessage-2.0.1 {ns_parsemessage plain case crlf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {OK}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body OK}

test ns_parsemessage-2.0.2 {ns_parsemessage plain case lf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {OK}} \n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body OK}


test ns_parsemessage-2.1.1 {ns_parsemessage empty body crlf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body {}}

test ns_parsemessage-2.1.2 {ns_parsemessage empty body lf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {}} \n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body {}}


test ns_parsemessage-2.2.1 {ns_parsemessage one-char body crlf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {X}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body X}

test ns_parsemessage-2.2.2 {ns_parsemessage empty body lf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {content-length: 2} {} {X}} \n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {content-length 2} body X}


test ns_parsemessage-2.3.1 {ns_parsemessage empty headers crlf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {} {OK}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {} body OK}

test ns_parsemessage-2.3.2 {ns_parsemessage empty headers lf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {} {OK}} \n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {} body OK}


test ns_parsemessage-2.4.1 {ns_parsemessage folded multi-line headers crlf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {h1: a} {h2: begin} {  continue} {h3: z} {OK}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {h1 a h2 {begin continue} h3 z} body OK}

test ns_parsemessage-2.4.2 {ns_parsemessage folded multi-line headers lf} -body {
    set d [ns_parsemessage [join {{HTTP/1.1 200 OK} {h1: a} {h2: begin} {  continue} {h3: z} {OK}} \r\n]]
    dict with d { list firstline $firstline headers [ns_set array $headers] body $body }
} -returnCodes {error ok} -result {firstline {HTTP/1.1 200 OK} headers {h1 a h2 {begin continue} h3 z} body OK}



#######################################################################################
#  test ns_getcsv
#######################################################################################

test ns_getcsv-1.0 {syntax: ns_getcsv} -body {
    ns_getcsv
} -returnCodes error -result {wrong # args: should be "ns_getcsv ?-delimiter /value/? ?-quotechar /value/? ?-trim? ?--? /channelId/ /varname/"}

test ns_getcsv-2.0 {ns_getcsv} -body {
    set csvFile [ns_server pagedir]/csv
    set f [open $csvFile]

    while {1} {
        set r [ns_getcsv $f line]
        switch $r {
           -1       {break}
            0       {}
            default {lappend lines $line}
        }
    }
    close $f
    set lines
} -cleanup {
    unset -nocomplain lines r f
} -returnCodes {ok error} -result {{aaa bbb ccc} {aaa {b
bb} ccc} {zzz yyy xxx} {{ 1 } { 2 } { 3 }} {includes(\")quote {quoted includes (") quote}} {elm2 {} empty} single {last3 empty {} {} {}}} ;# "

test ns_getcsv-2.1 {ns_getcsv with trim} -body {
    set csvFile [ns_server pagedir]/csv
    set f [open $csvFile]

    while {1} {
        set r [ns_getcsv -trim $f line]
        switch $r {
           -1       {break}
            0       {}
            default {lappend lines $line}
        }
    }
    close $f
    set lines
} -cleanup {
    unset -nocomplain lines r f
} -returnCodes {ok error} -result {{aaa bbb ccc} {aaa {b
bb} ccc} {zzz yyy xxx} {1 2 3} {includes(\")quote {quoted includes (") quote}} {elm2 {} empty} single {last3 empty {} {} {}}} ;# "


#######################################################################################
#  test ns_cbor syntax
#######################################################################################

test ns_cbor-1.0 {syntax: ns_cbor} -body {
    ns_cbor
} -returnCodes error -result {wrong # args: should be "ns_cbor parse|decode|scan ?/arg .../"}
# -returnCodes error -result {wrong # args: should be "ns_cbor parse ?/arg .../"}

test ns_cbor-1.1 {syntax: ns_cbor subcommand} -body {
    ns_cbor x
} -returnCodes error -result {ns_cbor: bad subcommand "x": must be parse, decode, or scan}
# -returnCodes error -result {ns_cbor: bad subcommand "x": must be parse}

test ns_cbor-1.2 {syntax: ns_cbor parse} -body {
    ns_cbor parse
} -returnCodes error -result {wrong # args: should be "ns_cbor parse ?-binary? ?-encoding hex|base64url|base64|binary? ?-scan? ?--? /value/"}

test ns_cbor-1.4 {syntax: bad -encoding value} -body {
    ns_cbor parse -encoding foo -- "\x00"
} -returnCodes error -result {bad option "foo": must be hex, base64url, base64, or binary}

test ns_cbor-1.5 {syntax: -encoding needs argument} -body {
    ns_cbor parse -encoding
} -returnCodes {error ok} -result {missing argument to -encoding}

test ns_cbor-1.6 {syntax: unknown option} -body {
    ns_cbor parse -bogus -- "\x00"
} -returnCodes error -result {wrong # args: should be "ns_cbor parse ?-binary? ?-encoding hex|base64url|base64|binary? ?-scan? ?--? /value/"}

test ns_cbor-1.7 {syntax: -- separates options from value} -body {
    # value looks like an option, must be treated as data after --
    # The first byte is '-' = 0x2d. In CBOR, 0x2d is: major type 1 (negative integer), additional info 13 -> -14
    ns_cbor parse -binary -- "-binary"
} -returnCodes {ok error} -result {-14}


#######################################################################################
#  ns_cbor functional tests
#######################################################################################

test ns_cbor-2.0 {ns_cbor parse simple map case} -body {
    set cbor_b64u "omNmbXRkbm9uZWdhdHRTdG10oA"
    set bin [ns_base64urldecode -binary -- $cbor_b64u]
    set value [ns_cbor parse -binary -encoding binary $bin]
} -result {fmt none attStmt {}}

test ns_cbor-2.1 {parse uint 0} -body {
    # 0x00 => unsigned int 0
    set bin [binary format H* 00]
    ns_cbor parse -binary -encoding binary $bin
} -result 0

test ns_cbor-2.2 {parse uint 23} -body {
    # 0x17 => 23
    set bin [binary format H* 17]
    ns_cbor parse -binary -encoding binary $bin
} -result 23

test ns_cbor-2.3 {parse uint 24} -body {
    # 0x18 0x18 => 24
    set bin [binary format H* 1818]
    ns_cbor parse -binary -encoding binary $bin
} -result 24

test ns_cbor-2.4 {parse negative int -1} -body {
    # 0x20 => -1
    set bin [binary format H* 20]
    ns_cbor parse -binary -encoding binary $bin
} -result -1

test ns_cbor-2.5 {parse negative int -24} -body {
    # 0x37 => -24
    set bin [binary format H* 37]
    ns_cbor parse -binary -encoding binary $bin
} -result -24

test ns_cbor-2.6 {parse simple true} -body {
    # 0xf5 => true
    set bin [binary format H* f5]
    ns_cbor parse -binary -encoding binary $bin
} -result 1

test ns_cbor-2.7 {parse simple false} -body {
    # 0xf4 => false
    set bin [binary format H* f4]
    ns_cbor parse -binary -encoding binary $bin
} -result 0

test ns_cbor-2.8 {parse bstr as binary} -constraints tcl86 -body {
    # 0x43 01 02 03 => bstr(3) = 0x010203
    set bin [binary format H* 43010203]
    set v [ns_cbor parse -binary -encoding binary $bin]
    binary encode hex $v
} -result 010203

test ns_cbor-2.9 {parse bstr as hex} -body {
    # same as above, but request hex output encoding
    set bin [binary format H* 43010203]
    ns_cbor parse -binary -encoding hex $bin
} -result 010203


test ns_cbor-2.10 {parse tstr "a"} -body {
    # 0x61 0x61 => "a"
    set bin [binary format H* 6161]
    ns_cbor parse -binary -encoding binary $bin
} -result a

test ns_cbor-2.11 {parse tstr "fmt"} -body {
    # 0x63 'f' 'm' 't'
    set bin [binary format H* 63666d74]
    ns_cbor parse -binary -encoding binary $bin
} -result fmt

test ns_cbor-2.12 {parse empty array} -body {
    # 0x80 => []
    set bin [binary format H* 80]
    ns_cbor parse -binary -encoding binary $bin
} -result {}

test ns_cbor-2.13 {parse array [1 2 3]} -body {
    # 0x83 01 02 03
    set bin [binary format H* 83010203]
    ns_cbor parse -binary -encoding binary $bin
} -result {1 2 3}

test ns_cbor-2.14 {parse empty map} -body {
    # 0xa0 => {}
    set bin [binary format H* a0]
    ns_cbor parse -binary -encoding binary $bin
} -result {}

test ns_cbor-2.15 {parse map {1:2, 3:-7}} -body {
    # a2 01 02 03 26
    set bin [binary format H* a201020326]
    ns_cbor parse -binary -encoding binary $bin
} -result {1 2 3 -7}

test ns_cbor-2.16 {parse COSE_Key-like map, check x/y lengths} -body {
    set cose_bin [binary format H* [string map {" " ""} {\
        a5 01 02 03 26 20 01 \
        21 58 20 0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20 \
        22 58 20 2122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40 \
    }]]
    set cose [ns_cbor parse -binary -encoding binary $cose_bin]
    list \
        alg [dict get $cose 3] \
        crv [dict get $cose -1] \
        xlen [string length [dict get $cose -2]] \
        ylen [string length [dict get $cose -3]]
} -result {alg -7 crv 1 xlen 32 ylen 32}

test ns_cbor-3.0 {scan returns bytes_consumed for single item} -body {
    # a0 => empty map, 1 byte
    set bin [binary format H* a0]
    set r [ns_cbor parse -scan -binary -encoding binary $bin]
    list [lindex $r 0] [lindex $r 1]
} -result {{} 1}

test ns_cbor-3.1 {scan consumes only first item} -body {
    # two items: a0 ({}), then 01
    set bin [binary format H* a001]
    set r [ns_cbor parse -scan -binary -encoding binary $bin]
    # should parse {} and report 1 byte consumed
    list [lindex $r 0] [lindex $r 1]
} -result {{} 1}

test ns_cbor-4.0 {truncated: additional length missing} -body {
    # 0x18 => uint with 1-byte argument, but missing that byte
    set bin [binary format H* 18]
    ns_cbor parse -binary -encoding binary $bin
} -returnCodes {ok error} -result {CBOR truncated input}

test ns_cbor-4.1 {truncated: bstr length says 3 but only 2 bytes provided} -body {
    # 0x43 => bstr(3) but only 0x01 0x02 present
    set bin [binary format H* 430102]
    ns_cbor parse -binary -encoding binary $bin
} -returnCodes {ok error} -result {CBOR truncated input}

test ns_cbor-4.2 {truncated: map claims 1 pair but value missing} -body {
    # a1 01 => map(1) with key=1 but missing value
    set bin [binary format H* a101]
    ns_cbor parse -binary -encoding binary $bin
} -returnCodes {ok error} -result {CBOR truncated input}


cleanupTests

#
# Local variables:
#    mode: tcl
#    tcl-indent-level: 4
#    indent-tabs-mode: nil
# End:
