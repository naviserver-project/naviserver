[include version_include.man]
[manpage_begin ns_json n [vset version]]
[moddesc {NaviServer Built-in Commands}]

[titledesc {JSON parser and generator for HTTP/WebAuthn needs.}]

[description] The command [cmd ns_json] provides a JSON (RFC 8259) parser and generator
integrated directly into NaviServer.

[para]
The parser is designed for server-side use cases where predictable behavior,
explicit type handling, and tight integration with NaviServer data structures
are required.  It parses exactly one JSON value from the input and reports
errors via Tcl exceptions.

[para]
In addition to returning conventional Tcl structures, the command supports
output formats that preserve JSON type information and lexical representations
explicitly (the [arg tripple] format|.  This enables reliable round-tripping between JSON input and output
and avoids unintended data transformations.

[para]
The [cmd "ns_json triples"] ensemble provides structured access to the
internal triples representation produced by
[cmd "ns_json parse -output triples"].  These commands allow querying
and updating JSON data in its typed intermediate form without
re-parsing or serializing JSON text.

[para]
The implementation performs strict validation of JSON syntax as defined by
RFC 8259.  Optional validation can be enabled to enforce additional constraints
on numeric values when integrating with Tcl numeric semantics.  The command
does not perform application-level transformations or coercions beyond these
well-defined checks.

[para]
Features such as comments, JSON5 extensions, or schema validation are
intentionally not supported.

[para]
The following design goals guided the implementation:

[list_begin itemized]
[item] Strict adherence to JSON syntax as defined in RFC 8259.
[item] Deterministic and explicit handling of JSON types.
[item] Preservation of numeric and string lexemes to support lossless round-trips.
[item] Efficient parsing directly from in-memory buffers.
[item] Support for incremental parsing via byte consumption reporting.
[item] Integration with Tcl values and NaviServer [cmd ns_set] structures.
[item] No dependency on external JSON libraries or Tcl packages.
[list_end]


[para]
The command supports multiple output formats to cover common integration
needs:

[list_begin itemized]
[item] [term dict] returns a Tcl representation using dict/list/scalars.
[item] [term triples] returns a flat list of triples [term "NAME TYPE VALUE"].
[item] [term set] returns a flattened [cmd ns_set] suitable for form handling.
[list_end]

These last two formats make JSON type information explicit and are intended
for programmatic processing and re-emission.


[section RATIONALE]

The [cmd ns_json] command is not only intended as a utility for application
developers, but is also designed as an integral part of NaviServerâ€™s internal
request processing infrastructure.

[para]
NaviServer has a long-standing model for handling structured request data,
most notably for [term application/x-www-form-urlencoded] and
[term multipart/form-data] requests, where incoming data is parsed early
and exposed through well-defined core data structures such as [cmd ns_set].
Higher-level facilities (e.g., page contracts, filters, and form handling)
are built on top of these parsed representations.

[para]
The [cmd ns_json] parser extends this model to JSON-based requests.
It is implemented in C, exposes a C-level parsing interface, and integrates
directly with NaviServer core abstractions.  This allows JSON request bodies
to be parsed automatically and made available to both internal code and
application-level Tcl code in a uniform and predictable way.

[para]
In particular, the [term set] output format is designed to mirror classical
form handling as closely as possible.  JSON objects and arrays are flattened
into an [cmd ns_set], structural paths are encoded into keys, and JSON type
information is preserved using sidecar fields.  This enables existing
infrastructure such as page contracts and request filters to operate on JSON
input without requiring JSON-specific logic.

[para]
Beyond application-level use, [cmd ns_json] is intended to be used internally
by NaviServer itself.  By exposing a small, well-defined C API and by relying
on common core data structures, the same parser can be reused for tasks such as
automatic parsing of JSON POST requests, incremental or streaming request
bodies, and other protocol-level features.

[para]
Most existing Tcl JSON libraries focus on convenience for scripting and map
JSON values directly to Tcl dicts and lists.  While suitable for many
application use cases, this approach loses explicit JSON type information and
often normalizes numeric values in ways that prevent reliable round-tripping.

[para]
The [term triples] output format addresses this by representing JSON values as
explicit [term "NAME TYPE VALUE"] triples.  JSON types and lexical
representations are preserved, enabling lossless round-tripping back to JSON
text and precise downstream processing.  This representation is well suited
for internal processing and for building higher-level functionality on top of
the core parser.

[para]
Rather than attempting to be a general-purpose JSON framework, [cmd ns_json]
focuses on predictable behavior, explicit typing, strict JSON syntax
validation, and deep integration with NaviServer internals.  Applications that
require schema validation, extended JSON dialects, or document-oriented
querying should use higher-level libraries built on top of this foundation.


[section {COMMANDS}]

[list_begin definitions]

[call [cmd "ns_json parse"] \
        [opt [option "-output dict|triples|set"]] \
        [opt [option "-scan"]] \
        [opt [option "-top any|container"]] \
        [opt [option "-validatenumbers"]] \
        [opt [option "-maxdepth [arg integer]"]] \
        [opt [option "-maxstring [arg integer]"]] \
        [opt [option "-maxcontainer [arg integer]"]] \
        [opt --] \
        [arg value]]

Parse a single JSON value from [arg value] and return the parsed Tcl value.
Multiple output formats are supported for mapping JSON values to Tcl data
structures.

[para] By default, the entire input must consist of exactly one JSON value
(optionally surrounded by whitespace).  Trailing non-whitespace data in the
input is treated as an error unless the option [option -scan] is specified.

[para] When the option [option -scan] is used, the result is a two-element
list.  The first element is the parsed value (or handle, depending on
[option -output]), and the second element is the number of bytes consumed
from the input.  This is useful for concatenated JSON streams or when JSON
is embedded in larger payloads.

[para] The following options are supported by [cmd "ns_json parse"]:

[list_begin options]

[opt_def -output [arg dict|triples|set]]
[para] Select the output format used to represent parsed JSON values.

[list_begin itemized]

[item] [arg dict]

[list_begin itemized]
[item] JSON strings are returned as Tcl strings.
[item] JSON numbers are returned as their original lexical representation
       (as Tcl strings), preserving precision and formatting.
[item] JSON arrays are returned as Tcl lists.
[item] JSON objects are returned as Tcl dicts.
[item] JSON booleans are returned as Tcl boolean values.
[item] JSON [term null] is returned as a distinguished sentinel value
       [const __NS_JSON_NULL__] so it can be distinguished from a regular Tcl
       string. The helper [cmd "ns_json isnull"] checks for this sentinel.
[list_end]

[item] [arg triples]

[para] Return a flat list of triples of the form:

[example_begin]
 NAME TYPE VALUE NAME TYPE VALUE ...
[example_end]

[para] The [term TYPE] element explicitly records the JSON type and allows
lossless round-tripping back to JSON. All JSON numbers use the type
[term number], independent of validation options.

[para] For arrays, the VALUE of an [term array] triple is a list of indexed
triples of the form [term "{index type value ...}"] using zero-based indices.
For objects, the VALUE of an [term object] triple is a list of triples of the
form [term "{name type value ...}"].

[para] JSON [term null] is represented by TYPE [term null] and the sentinel value
[const __NS_JSON_NULL__].


[item] [arg set]


[para] Return a flattened [cmd ns_set] handle. Nested paths are encoded into
keys using [term "/"] as a separator. Each value stores its JSON type in a
sidecar key [term ".type"].

[para] Array elements are stored using zero-based numeric path segments (e.g.,
[term "d/0"], [term "d/1"]), consistent with the array indexing used by
[arg triples]. JSON [term null] is stored with value [const __NS_JSON_NULL__]
and its [term ".type"] entry is set to [term null].

[list_end]

[example_begin]
 set JSON {{
   "a": 1,
   "b": true,
   "c": null,
   "d": [lb]2, 3[rb]
 }}
 
 # using -output dict
 ns_json parse -output dict $JSON
 ## output: a 1 b true c __NS_JSON_NULL__ d {2 3}
 
 # using -output triples
 ns_json parse -output triples $JSON
 ## output: a number 1 b boolean true c null __NS_JSON_NULL__ d array {0 number 2 1 number 3}
 
 # using -output set
 set s [lb]ns_json parse -output set $JSON[rb]
 ns_set array $s
 ## output: a.type number a 1 b.type boolean b true c.type null c __NS_JSON_NULL__ d/0.type number d/0 2 d/1.type number d/1 3
[example_end]

[opt_def -top [arg any|container]]
[para] Control the accepted top-level JSON value.

[list_begin itemized]
[item] [term any] (default) accepts any JSON value.
[item] [term container] accepts only JSON objects or arrays at the top level.
[list_end]

[opt_def -maxdepth [arg n]]
[para] Limit maximum nesting depth.  A value of 0 means no limit.
The default is 1000.

[opt_def -maxstring [arg n]]
[para] Limit maximum decoded string length in bytes.
A value of 0 means no limit.  The default is unlimited.

[opt_def -maxcontainer [arg n]]
[para] Limit the maximum number of elements in arrays or objects.
A value of 0 means no limit.  The default is unlimited.

[opt_def -scan]
[para] Return a two-element list of the form
[term "{value bytes_consumed}"] instead of just the parsed value.

[opt_def -validatenumbers]
[para] Additionally validate JSON numbers for numeric use in Tcl.

[list_begin itemized]
[item] JSON number syntax is always validated according to RFC 8259.
[item] With [option -validatenumbers], numbers containing a fractional part
or exponent are additionally converted to a Tcl double and rejected
if the result is not finite (e.g., overflows to [term Inf] or
[term -Inf], or becomes [term NaN]).
[item] Number lexemes are always preserved as strings; this option affects
acceptance only, not the returned representation.
[list_end]

[list_end]



[call [cmd "ns_json value"] \
        [opt [option "-type auto|string|number|boolean|null|object|array"]] \
        [opt [option "-pretty"]] \
        [opt --] \
        [arg value]]

Convert a Tcl value to its JSON representation and return the resulting
JSON text.

[para] The option [option -type] controls how the Tcl value is interpreted
and encoded as JSON.  The default is [term auto], which selects the JSON
type based on the Tcl value.

[para] The following options are supported by [cmd "ns_json value"]:

[list_begin options]

[opt_def -type [arg auto|string|number|boolean|null|object|array]]
[para] Specify the JSON type to use when encoding the value.

[list_begin itemized]

[item] [term auto]
[para] Determine the JSON type automatically from the Tcl value using the
following precedence rules:

[list_begin itemized]
[item] If the value is a triples list whose first triple has an explicit
container type marker ([term object] or [term array]), it is treated as
a JSON container and encoded accordingly.
[item] Otherwise, values matching a valid JSON number lexeme are encoded
as JSON numbers.
[item] Tcl boolean values are encoded as JSON booleans.
[item] The null sentinel value [const __NS_JSON_NULL__] is encoded as JSON [term null].
[item] All other values are encoded as JSON strings.
[list_end]

[para] In [term auto] mode, only container triples with an explicit
[term object] or [term array] type marker in the first triple are recognized.
Scalar-looking triples such as

[example_begin]
 {0 number 1}
[example_end]

are not interpreted as JSON containers and are instead treated as ordinary
Tcl values.

[para] Since automatic type detection cannot preserve intent in ambiguous cases,
it is recommended to specify the JSON type explicitly via [option -type] when
generating JSON for external interfaces.

[item] [term string]
[para] Encode the value as a JSON string.

[item] [term number]
[para] Encode the value as a JSON number.  The string representation of the
Tcl value is used as the JSON number lexeme.

[item] [term boolean]
[para] Encode the value as a JSON boolean.

[item] [term null]
[para] Encode the value as JSON [term null].  The input value is ignored.

[item] [term object]
[para] Encode the value as a JSON object.  The input must be a flat list of
triples as returned by [option "-output triples"].

[para] Each triple has the form:

[example_begin]
 key type value
[example_end]

[para] The [term type] element specifies the JSON type for each value and
enables unambiguous encoding (e.g., boolean vs string, number vs string, null
vs string).  Values of nested objects and arrays must themselves be provided
in triples form.

[item] [term array]
[para] Encode the value as a JSON array.  The input must be a flat list of
triples as returned by [option "-output triples"] using zero-based array
indices as keys.

[para] The [term type] element specifies the JSON type for each element and
enables unambiguous encoding.  Values of nested objects and arrays must
also be provided in triples form.

[list_end]

[opt_def -pretty]
[para] Pretty-print JSON output using newlines and indentation.  This option
affects only JSON containers (objects and arrays).  Empty containers are still
rendered in compact form as [term "{}"] and [term {[]}].

[example_begin]
 # Pretty-print a JSON object via triples (lossless round-trip of values)
 set JSON {{"user":{"id":7,"name":"Alice","flags":{"admin":false,"active":true}}}}
 
 # Parse to typed triples and re-emit pretty-printed JSON
 set triples [lb]ns_json parse -output triples $JSON[rb]
 ns_json value -pretty -type object $triples
 ## output:
 ## {
 ##   "user": {
 ##     "id": 7,
 ##     "name": "Alice",
 ##     "flags": {
 ##       "admin": false,
 ##       "active": true
 ##     }
 ##   }
 ## }
 [example_end]

[list_end]

Quick examples:

[example_begin]
 ns_json value -type object {a number 1 b boolean 1 c string x n null __NS_JSON_NULL__}
 ## output: {"a":1,"b":true,"c":"x","n":null}
 
 ns_json value -type array {0 number 1 1 number 2 2 number 3 3 null __NS_JSON_NULL__}
 ## output: [lb]1,2,3,null[rb]
 
 # AUTO container detection (explicit container marker present)
 set JSON {{"user":{"id":7}}}
 set t [lb]ns_json parse -output triples $JSON[rb]
 ## output: user object {id number 7}
 ns_json value $t
 ## output: {"user":{"id":7}}
 
 # Note: Scalar-looking triples are not auto-detected as containers
 ns_json value {0 number 1}
 ## output: "0 number 1"
[example_end]



[call [cmd "ns_json isnull"] \
        [arg value]]

Return a boolean indicating whether [arg value] is the distinguished JSON null
sentinel used in [term dict] output.


[call [cmd "ns_json keyinfo"] \
        [arg key]]

Interpret a flattened key produced by [term set] output and return a dict:

[example_begin]
key <unescaped-base-key> field <field-or-empty>
[example_end]

[para]
The base key is the path key with escaping reversed and sidecar suffix removed.
Currently the sidecar field [term ".type"] is recognized.  Other sidecar fields
may be added in the future.


[call [cmd "ns_json keyencode"] \
        [arg string]]

Return the escaped form of an arbitrary string for use as a single path segment
in [term set] output keys.  The escaping rules are:

[list_begin itemized]
[item] [term "~"] is encoded as [term "~0"]
[item] [term "/"] is encoded as [term "~1"]
[item] [term "."] is encoded as [term "~2"]
[list_end]


[call [cmd "ns_json keydecode"] \
        [arg string]]

Return the unescaped form of an escaped path segment (inverse of [cmd keyencode]).


[call [cmd "ns_json triples getvalue"] \
        [opt [option "-path [arg value]"]] \
        [opt [option "-pointer [arg value]"]] \
        [opt [option "-indices"]] \
        [opt [option "-output json|triples"]] \
        [opt [option "-pretty"]] \
        [opt --] \
        [arg triples]]


[para]
Return the value located at the specified path within a triples
structure.

[para]
Exactly one of [option -path] or [option -pointer] must be specified.

[list_begin itemized]
[item] [option "-path [arg value]"] specifies a Tcl list describing the
hierarchical location.

[item] [option "-pointer [arg value]"] specifies a JSON Pointer (RFC 6901)
string.  A trailing [const /] denotes an empty reference token and is
not ignored.

[item] [option -indices] causes the command to return a Tcl index path
suitable for use with [cmd lindex] or [cmd lset] on the original
triples list instead of the value itself.

[item] [option "-output json|triples"] controls the output format.
The default is [const json].

[list_begin itemized]
[item] [const json] (default) returns the selected value formatted as JSON text. Note that
  for strings, the commands provides the quoting needed for JSON.
[item] [const triples] returns the stored Tcl representation.
For scalar values this is the scalar Tcl value.
For container values this is the container-content triples list.
[list_end]

[item] [option -pretty] applies only when [option "-output json"] is used and
formats the JSON output with indentation.
[list_end]

[example_begin]
 set t [lb]ns_json parse -output triples {{"o":{"x":1},"s":"Bob"}}[rb]
 
 # Default: JSON projection
 ns_json triples getvalue -pointer /o $t
 ## output: {"x":1}
 
 ns_json triples getvalue -pointer /s $t
 ## output: "Bob"
 
 # Raw triples/Tcl representation
 ns_json triples getvalue -output triples -pointer /o $t
 ## output: x number 1
[example_end]


[call [cmd "ns_json triples gettype"] \
        [opt [option "-path [arg value]"]] \
        [opt [option "-pointer [arg value]"]] \
        [opt [option "-indices"]] \
        [opt --] \
        [arg triples]]

[para]
Return the JSON type token at the specified path within a triples
structure.

[para]
The result is one of:
[const string], [const number], [const boolean],
[const null], [const object], or [const array].


[para]
The location within the triples structure is specified via either
[option -path] or [option -pointer].  Exactly one of these options must
be provided.

[list_begin itemized]
[item]
[option "-path [arg value]"] specifies a Tcl list describing the
hierarchical location.

[item]
[option "-pointer [arg value]"] specifies a JSON Pointer (RFC 6901)
string.  A trailing [const /] denotes an empty reference token and is
not ignored.
[list_end]

[para]
With [option -indices], the command returns an index path pointing to
the type element inside the triples list.  This index path can be
used with [cmd lindex] or [cmd lset].

[example_begin]
 set t [lb]ns_json parse -output triples {{"user":{"flags":{"active":true}}}}[rb]
 
 ns_json triples gettype -pointer /user/flags/active $t
 ## output: boolean
[example_end]


[call [cmd "ns_json triples setvalue"] \
        [opt [option "-path [arg value]"]] \
        [opt [option "-pointer [arg value]"]] \
        [opt [option "-type auto|string|number|boolean|null|object|array"]] \
        [opt --] \
        [arg triples] \
        [arg value] \
        ]

[para]
Update the value at the specified path within a triples structure and
return a modified triples list.

[para]
The location to be updated within the triples structure is specified via
either [option -path] or [option -pointer].  Exactly one of these options
must be provided.

[list_begin itemized]
[item]
[option "-path [arg value]"] specifies a Tcl list describing the
hierarchical location.

[item]
[option "-pointer [arg value]"] specifies a JSON Pointer (RFC 6901)
string.  A trailing [const /] denotes an empty reference token and is
not ignored.
[list_end]

[para]
The optional [option -type] flag controls how the new value is
interpreted:

[list_begin itemized]
[item]
[const auto] (default): infer the type from the value, while preserving
and validating existing leaf types where applicable (for example,
number slots remain numeric and reject invalid number lexemes).

[item]
Explicit types ([const string], [const number], [const boolean],
[const null], [const object], [const array]) enforce validation and
normalization of the supplied value.

[item]
For container types ([const object] and [const array]), the supplied
value must be a triples list.  The empty list [const {}] represents
an empty container.
[list_end]

[para]
Setting a null value can be done using the sentinel
[const __NS_JSON_NULL__], which stores a [const null] leaf.

[example_begin]
 set t  [lb]ns_json parse -output triples {{"user":{"name":"Alice"}}}[rb]
 ns_json triples gettype -path {user name} $t
 ## output: string
 
 set t2 [lb]ns_json triples setvalue -path {user name} $t __NS_JSON_NULL__[rb]
 ns_json triples gettype -path {user name} $t2
 ## output: null
[example_end]


[list_end]


[section "Triple Format"]

[para]
The triples representation is a typed Tcl list format used internally
by [cmd ns_json].  It is produced by:

[list_begin itemized]
[item] [cmd "ns_json parse -output triples"]
[item] [cmd "ns_json triples getvalue -output triples"]
[list_end]

[para]
A triples list has the structure:

[example_begin]
 key-or-index type value key-or-index type value ...
[example_end]

[para]
Each logical element consists of three consecutive fields:

[list_begin itemized]
[item] A key (for objects) or numeric index (for arrays)
[item] A type token
[item] A value
[list_end]

[para]
Valid type tokens are:
[const string], [const number], [const boolean],
[const null], [const object], and [const array].

[para]
The meaning of the [arg value] field depends on the type:

[list_begin itemized]

[item]
[const string]: the value is a Tcl string containing the decoded
JSON string (without surrounding quotes).

[item] [const number]: the value is a Tcl string containing the original
JSON number lexeme.  The lexeme must conform to JSON number syntax.

[item] [const boolean]: the value is the canonical Tcl representation of
the JSON boolean ([const true] or [const false]).

[item] [const null]: the value is the null sentinel
[const __NS_JSON_NULL__].

[item] [const object]: the value is a triples list describing the object
members.  The empty list [const {}] represents an empty object.

[item] [const array]: the value is a triples list describing the array
elements.  The empty list [const {}] represents an empty array.

[list_end]

[para]
Example:

[example_begin]
 set t [lb]ns_json parse -output triples {{"o":{"x":1},"s":"Bob","n":null}}[rb]
 ## output: o object {x number 1} s string Bob n null __NS_JSON_NULL__
[example_end]

[para]
The triples representation preserves JSON type information explicitly
and allows efficient navigation and modification without re-parsing
JSON text.



[section EXAMPLES]

Parse JSON as dict
[example_begin]
 ns_json parse {{"a":1,"b":true,"c":"x"}}
 ## a 1 b true c x
 
 # Nested objects become nested dicts.
 set d [lb]ns_json parse {{
   "user": {
     "id": 7,
     "name": "Alice",
     "flags": {
       "admin": false,
       "active": true
     }
   },
   "meta": {
     "count": 2
   }
 }}[rb]
 # -> user {id 7 name Alice flags {admin false active true}} meta {count 2}
 
 # Access nested values with dict get:
 dict get $d user name           ;# -> Alice
 dict get $d user flags active   ;# -> true
 dict get $d meta count          ;# -> 2
[example_end]

Parse JSON with explicit types (triples)
[example_begin]
 ns_json parse -output triples {{"a":1,"b":true}}
 ## a number 1 b boolean true
[example_end]

Parse JSON to a flattened ns_set
[example_begin]
 set s [lb]ns_json parse -output set {{
   "x": { "y":"z" },
   "arr": [lb]10,20[rb]
 }}[rb]
 ns_set get $s x/y
 ## output: z
 
 ns_set get $s x/y.type 
 ## output: string
 
 ns_set get $s arr/0
 ## output: 10
 
 ns_set get $s arr/0.type
 ## output: int
 
 ns_set format $s
 ## output:
   ns_json:
    x/y.type: string
    x/y: z
    arr/0.type: number
    arr/0: 10
    arr/1.type: number
    arr/1: 20
[example_end]

Scan mode
[example_begin]
 ns_json parse -scan {{"a":1}{"b":2}}
 ## output: {{a 1} 7}
 
 # Parse the first JSON object and return the number of bytes consumed,
 # leaving a useful trailer (e.g., a checksum) after the JSON.
 set data {{"a":1} CRC32=0x3A5F2C19}
 set r [lb]ns_json parse -scan $data[rb]
 ## output: {{a 1} 7}
 
 # The consumed byte count lets you slice off the trailer:
 lassign $r d consumed
 set trailer [lb]string range {{"a":1} CRC32=0x3A5F2C19} $consumed end[rb]
 ## output: CRC32=0x3A5F2C19
[example_end]

Encode JSON strings safely
[example_begin]
 ns_json value -type string {a"b\c}
 ## output: "a\"b\\c"
[example_end]

Generate JSON from triples
[example_begin]
 ns_json value -type object {a number 1 b boolean 1 c string x n null __NS_JSON_NULL__}
 ## output: {"a":1,"b":true,"c":"x","n":null}
[example_end]

Key helpers for set output
[example_begin]
 ns_json keyencode {a.b}
 ## output: a~2b
 
 ns_json keyinfo {a~2b.type}
 ## output: key a.b field type
[example_end]


[subsection "Example: Navigating and Updating JSON Structures via Triples"]

[para]
Assume a JSON document with the following structure,
where a response from a sever contains an array of invoices,
and every invoice contains a [const BillEmail]
(irrelevant parts omitted):

[example_begin]
 {
   "QueryResponse": {
     "Invoice": [lb]{
         ...,
         "BillEmail": {
           "Address": "joe.user@nowhere.com"
         },
         ...
     }[rb],
     ...
   }
 }
[example_end]

[para]
Parse the JSON document into triples:

[example_begin]
 set t [lb]ns_json parse -output triples $JSON[rb]
[example_end]

[para] Retrieve the [const BillEmail] object of the first invoice
(default output is JSON):

[example_begin]
 ns_json triples getvalue -pointer /QueryResponse/Invoice/0/BillEmail $t
 ## output: {"Address":"joe.user@nowhere.com"}
[example_end]

[para]
Update the email address:

[example_begin]
 set t2 [lb]ns_json triples setvalue -pointer /QueryResponse/Invoice/0/BillEmail/Address $t "customer@somewhere.com"[rb]
[example_end]

[para]
Inspect the updated [const BillEmail] object (using formatted JSON output):

[example_begin]
 ns_json triples getvalue -pretty -pointer /QueryResponse/Invoice/0/BillEmail $t2
 ## output:
 {
   "Address": "customer@somewhere.com"
 }
[example_end]


[see_also ns_set ns_base64 ns_cbor]
[keywords "global built-in" JSON WebAuthn encoding parsing]
[manpage_end]
