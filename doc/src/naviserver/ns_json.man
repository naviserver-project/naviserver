[include version_include.man]
[manpage_begin ns_json n [vset version]]
[moddesc {NaviServer Built-in Commands}]

[titledesc {JSON parser and generator for HTTP/WebAuthn needs.}]

[description] The command [cmd ns_json] provides a JSON (RFC 8259) parser and generator
integrated directly into NaviServer.

[para]
The parser is designed for server-side use cases where predictable behavior,
explicit type handling, and tight integration with NaviServer data structures
are required.  It parses exactly one JSON value from the input and reports
errors via Tcl exceptions.

[para]
In addition to returning conventional Tcl structures, the command supports
output formats that preserve JSON type information and lexical representations
explicitly.  This enables reliable round-tripping between JSON input and output
and avoids unintended data transformations.

[para]
The implementation performs strict validation of JSON syntax as defined by
RFC 8259.  Optional validation can be enabled to enforce additional constraints
on numeric values when integrating with Tcl numeric semantics.  The command
does not perform application-level transformations or coercions beyond these
well-defined checks.

[para]
Features such as comments, JSON5 extensions, or schema validation are
intentionally not supported.

[para]
The following design goals guided the implementation:

[list_begin itemized]
[item] Strict adherence to JSON syntax as defined in RFC 8259.
[item] Deterministic and explicit handling of JSON types.
[item] Preservation of numeric and string lexemes to support lossless round-trips.
[item] Efficient parsing directly from in-memory buffers.
[item] Support for incremental parsing via byte consumption reporting.
[item] Integration with Tcl values and NaviServer [cmd ns_set] structures.
[item] No dependency on external JSON libraries or Tcl packages.
[list_end]


[para]
The command supports multiple output formats to cover common integration
needs:

[list_begin itemized]
[item] [term dict] returns a Tcl representation using dict/list/scalars.
[item] [term triples] returns a flat list of triples [term "NAME TYPE VALUE"].
[item] [term set] returns a flattened [cmd ns_set] suitable for form handling.
[list_end]

These last two formats make JSON type information explicit and are intended
for programmatic processing and re-emission.


[section RATIONALE]

The [cmd ns_json] command is not only intended as a utility for application
developers, but is also designed as an integral part of NaviServerâ€™s internal
request processing infrastructure.

[para]
NaviServer has a long-standing model for handling structured request data,
most notably for [term application/x-www-form-urlencoded] and
[term multipart/form-data] requests, where incoming data is parsed early
and exposed through well-defined core data structures such as [cmd ns_set].
Higher-level facilities (e.g., page contracts, filters, and form handling)
are built on top of these parsed representations.

[para]
The [cmd ns_json] parser extends this model to JSON-based requests.
It is implemented in C, exposes a C-level parsing interface, and integrates
directly with NaviServer core abstractions.  This allows JSON request bodies
to be parsed automatically and made available to both internal code and
application-level Tcl code in a uniform and predictable way.

[para]
In particular, the [term set] output format is designed to mirror classical
form handling as closely as possible.  JSON objects and arrays are flattened
into an [cmd ns_set], structural paths are encoded into keys, and JSON type
information is preserved using sidecar fields.  This enables existing
infrastructure such as page contracts and request filters to operate on JSON
input without requiring JSON-specific logic.

[para]
Beyond application-level use, [cmd ns_json] is intended to be used internally
by NaviServer itself.  By exposing a small, well-defined C API and by relying
on common core data structures, the same parser can be reused for tasks such as
automatic parsing of JSON POST requests, incremental or streaming request
bodies, and other protocol-level features.

[para]
Most existing Tcl JSON libraries focus on convenience for scripting and map
JSON values directly to Tcl dicts and lists.  While suitable for many
application use cases, this approach loses explicit JSON type information and
often normalizes numeric values in ways that prevent reliable round-tripping.

[para]
The [term triples] output format addresses this by representing JSON values as
explicit [term "NAME TYPE VALUE"] triples.  JSON types and lexical
representations are preserved, enabling lossless round-tripping back to JSON
text and precise downstream processing.  This representation is well suited
for internal processing and for building higher-level functionality on top of
the core parser.

[para]
Rather than attempting to be a general-purpose JSON framework, [cmd ns_json]
focuses on predictable behavior, explicit typing, strict JSON syntax
validation, and deep integration with NaviServer internals.  Applications that
require schema validation, extended JSON dialects, or document-oriented
querying should use higher-level libraries built on top of this foundation.


[section {COMMANDS}]

[list_begin definitions]

[call [cmd "ns_json parse"] \
        [opt [option "-output dict|triples|set"]] \
        [opt [option "-scan"]] \
        [opt [option "-top any|container"]] \
        [opt [option "-validatenumbers"]] \
        [opt [option "-maxdepth [arg integer]"]] \
        [opt [option "-maxstring [arg integer]"]] \
        [opt [option "-maxcontainer [arg integer]"]] \
        [opt --] \
        [arg value]]

Parse a single JSON value from [arg value] and return the parsed Tcl value.
Multiple output formats are supported for mapping JSON values to Tcl data
structures.

[para] By default, the entire input must consist of exactly one JSON value
(optionally surrounded by whitespace).  Trailing non-whitespace data in the
input is treated as an error unless the option [option -scan] is specified.

[para] When the option [option -scan] is used, the result is a two-element
list.  The first element is the parsed value (or handle, depending on
[option -output]), and the second element is the number of bytes consumed
from the input.  This is useful for concatenated JSON streams or when JSON
is embedded in larger payloads.

[para] The following options are supported by [cmd "ns_json parse"]:

[list_begin options]

[opt_def -output [arg dict|triples|set]]
[para] Select the output format used to represent parsed JSON values.

[list_begin itemized]

[item] [arg dict]

[list_begin itemized]
[item] JSON strings are returned as Tcl strings.
[item] JSON numbers are returned as their original lexical representation
       (as Tcl strings), preserving precision and formatting.
[item] JSON arrays are returned as Tcl lists.
[item] JSON objects are returned as Tcl dicts.
[item] JSON booleans are returned as Tcl boolean values.
[item] JSON [term null] is returned as a distinguished sentinel value
       [const __NS_JSON_NULL__] so it can be distinguished from a regular Tcl
       string. The helper [cmd "ns_json isnull"] checks for this sentinel.
[list_end]

[item] [arg triples]

[para] Return a flat list of triples of the form:

[example_begin]
 NAME TYPE VALUE NAME TYPE VALUE ...
[example_end]

[para] The [term TYPE] element explicitly records the JSON type and allows
lossless round-tripping back to JSON. All JSON numbers use the type
[term number], independent of validation options.

[para] For arrays, the VALUE of an [term array] triple is a list of indexed
triples of the form [term "{index type value ...}"] using zero-based indices.
For objects, the VALUE of an [term object] triple is a list of triples of the
form [term "{name type value ...}"].

[para] JSON [term null] is represented by TYPE [term null] and the sentinel value
[const __NS_JSON_NULL__].


[item] [arg set]


[para] Return a flattened [cmd ns_set] handle. Nested paths are encoded into
keys using [term "/"] as a separator. Each value stores its JSON type in a
sidecar key [term ".type"].

[para] Array elements are stored using zero-based numeric path segments (e.g.,
[term "d/0"], [term "d/1"]), consistent with the array indexing used by
[arg triples]. JSON [term null] is stored with value [const __NS_JSON_NULL__]
and its [term ".type"] entry is set to [term null].

[list_end]

[example_begin]
 set JSON {{
   "a": 1,
   "b": true,
   "c": null,
   "d": [lb]2, 3[rb]
 }}
 
 # using -output dict
 ns_json parse -output dict $JSON
 ## output: a 1 b true c __NS_JSON_NULL__ d {2 3}
 
 # using -output triples
 ns_json parse -output triples $JSON
 ## output: a number 1 b boolean true c null __NS_JSON_NULL__ d array {0 number 2 1 number 3}
 
 # using -output set
 set s [lb]ns_json parse -output set $JSON[rb]
 ns_set array $s
 ## output: a.type number a 1 b.type boolean b true c.type null c __NS_JSON_NULL__ d/0.type number d/0 2 d/1.type number d/1 3
[example_end]

[opt_def -top [arg any|container]]
[para] Control the accepted top-level JSON value.

[list_begin itemized]
[item] [term any] (default) accepts any JSON value.
[item] [term container] accepts only JSON objects or arrays at the top level.
[list_end]

[opt_def -maxdepth [arg n]]
[para] Limit maximum nesting depth.  A value of 0 means no limit.
The default is 1000.

[opt_def -maxstring [arg n]]
[para] Limit maximum decoded string length in bytes.
A value of 0 means no limit.  The default is unlimited.

[opt_def -maxcontainer [arg n]]
[para] Limit the maximum number of elements in arrays or objects.
A value of 0 means no limit.  The default is unlimited.

[opt_def -scan]
[para] Return a two-element list of the form
[term "{value bytes_consumed}"] instead of just the parsed value.

[opt_def -validatenumbers]
[para] Additionally validate JSON numbers for numeric use in Tcl.

[list_begin itemized]
[item] JSON number syntax is always validated according to RFC 8259.
[item] With [option -validatenumbers], numbers containing a fractional part
or exponent are additionally converted to a Tcl double and rejected
if the result is not finite (e.g., overflows to [term Inf] or
[term -Inf], or becomes [term NaN]).
[item] Number lexemes are always preserved as strings; this option affects
acceptance only, not the returned representation.
[list_end]

[list_end]



[call [cmd "ns_json value"] \
        [opt [option "-type auto|string|number|boolean|null|object|array"]] \
        [opt [option "-pretty"]] \
        [opt [option "-validatenumbers"]] \
        [opt --] \
        [arg value]]

Convert a Tcl value to its JSON representation and return the resulting
JSON text.

[para] The option [option -type] controls how the Tcl value is interpreted
and encoded as JSON.  The default is [term auto], which selects the JSON
type based on the Tcl value.

[para] The following options are supported by [cmd "ns_json value"]:

[list_begin options]

[opt_def -type [arg auto|string|number|boolean|null|object|array]]
[para] Specify the JSON type to use when encoding the value.

[list_begin itemized]

[item] [term auto]
[para] Determine the JSON type automatically from the Tcl value using the
following precedence rules:

[list_begin itemized]
[item] Values matching a valid JSON number lexeme are encoded as JSON numbers.
[item] Tcl boolean values are encoded as JSON booleans.
[item] The null sentinel value [const __NS_JSON_NULL__] is encoded as JSON [term null].
[item] All other values are encoded as JSON strings.
[list_end]

[para] In this mode, typed triples are not interpreted as container input.
To generate JSON objects or arrays from triples, the option
[option "-type object"] or [option "-type array"] must be specified explicitly.

[para] Since automatic type detection cannot preserve intent in ambiguous cases,
it is recommended to specify the JSON type explicitly via [option -type] when
generating JSON for external interfaces.

[item] [term string]
[para] Encode the value as a JSON string.

[item] [term number]
[para] Encode the value as a JSON number.  The string representation of the
Tcl value is used as the JSON number lexeme.

[item] [term boolean]
[para] Encode the value as a JSON boolean.

[item] [term null]
[para] Encode the value as JSON [term null].  The input value is ignored.

[item] [term object]
[para] Encode the value as a JSON object.  The input must be a flat list of
triples as returned by [option "-output triples"].
The [term TYPE] element specifies the JSON type for each value and
enables unambiguous encoding (e.g., boolean vs string, number vs string, null
vs string). Also the values of nested objects and arrays
are expected in the form of triples.

[item] [term array]
[para] Encode the value as a JSON array.  The input must be a flat list of
triples as returned by [option "-output triples"]
using zero-based array indices.
The [term TYPE] element specifies the JSON type for each element and
enables unambiguous encoding. Also the values of nested objects and arrays
are expected in the form of triples.

[list_end]

[opt_def -pretty]
[para] Pretty-print JSON output using newlines and indentation.  This option
affects only JSON containers (objects and arrays).  Empty containers are still
rendered in compact form as [term "{}"] and [term {[]}].

[example_begin]
 # Pretty-print a JSON object via triples (lossless round-trip of values)
 set JSON {{"user":{"id":7,"name":"Alice","flags":{"admin":false,"active":true}}}}
 
 # Parse to typed triples and re-emit pretty-printed JSON
 set triples [lb]ns_json parse -output triples $JSON[rb]
 ns_json value -pretty -type object $triples
 ## output:
 ## {
 ##   "user": {
 ##     "id": 7,
 ##     "name": "Alice",
 ##     "flags": {
 ##       "admin": false,
 ##       "active": true
 ##     }
 ##   }
 ## }
 [example_end]


[opt_def -validatenumbers]
[para] Validate JSON number lexemes before emitting them.

[list_begin itemized]
[item] When used with [option "-type number"], the string representation of the
Tcl value is validated according to RFC 8259 before being emitted as a JSON
number.
[item] This rejects non-JSON number spellings such as [const NaN], [const Inf],
leading plus signs (e.g., [const +1]), leading decimal points (e.g., [const .5]),
trailing decimal points (e.g., [const 1.]), or leading-zero integers
(e.g., [const 01]).
[item] When used with [option "-type auto"], number candidates are validated
before being classified as JSON numbers.
[list_end]

[list_end]


[example_begin]
 ns_json value -type object {a number 1 b boolean 1 c string x n null __NS_JSON_NULL__}
 ## output: {"a":1,"b":true,"c":"x","n":null}
 
 ns_json value -type array {0 number 1 1 number 2 2 number 3 3 null __NS_JSON_NULL__}
 ## output: [lb]1,2,3,null[rb]
 
 ns_json value -type number 01
 ## output: 01
 ns_json value -validatenumbers -type number 01
 ## output: ns_json: parse error at byte 1: invalid number
[example_end]



[call [cmd "ns_json isnull"] \
        [arg value]]

Return a boolean indicating whether [arg value] is the distinguished JSON null
sentinel used in [term dict] output.


[call [cmd "ns_json keyinfo"] \
        [arg key]]

Interpret a flattened key produced by [term set] output and return a dict:

[example_begin]
key <unescaped-base-key> field <field-or-empty>
[example_end]

[para]
The base key is the path key with escaping reversed and sidecar suffix removed.
Currently the sidecar field [term ".type"] is recognized.  Other sidecar fields
may be added in the future.


[call [cmd "ns_json keyencode"] \
        [arg string]]

Return the escaped form of an arbitrary string for use as a single path segment
in [term set] output keys.  The escaping rules are:

[list_begin itemized]
[item] [term "~"] is encoded as [term "~0"]
[item] [term "/"] is encoded as [term "~1"]
[item] [term "."] is encoded as [term "~2"]
[list_end]


[call [cmd "ns_json keydecode"] \
        [arg string]]

Return the unescaped form of an escaped path segment (inverse of [cmd keyencode]).

[list_end]



[section EXAMPLES]

Parse JSON as dict
[example_begin]
 ns_json parse {{"a":1,"b":true,"c":"x"}}
 ## a 1 b true c x
 
 # Nested objects become nested dicts.
 set d [lb]ns_json parse {{
   "user": {
     "id": 7,
     "name": "Alice",
     "flags": {
       "admin": false,
       "active": true
     }
   },
   "meta": {
     "count": 2
   }
 }}[rb]
 # -> user {id 7 name Alice flags {admin false active true}} meta {count 2}
 
 # Access nested values with dict get:
 dict get $d user name           ;# -> Alice
 dict get $d user flags active   ;# -> true
 dict get $d meta count          ;# -> 2
[example_end]

Parse JSON with explicit types (triples)
[example_begin]
 ns_json parse -output triples {{"a":1,"b":true}}
 ## a number 1 b boolean true
[example_end]

Parse JSON to a flattened ns_set
[example_begin]
 set s [lb]ns_json parse -output set {{
   "x": { "y":"z" },
   "arr": [lb]10,20[rb]
 }}[rb]
 ns_set get $s x/y
 ## output: z
 
 ns_set get $s x/y.type 
 ## output: string
 
 ns_set get $s arr/0
 ## output: 10
 
 ns_set get $s arr/0.type
 ## output: int
 
 ns_set format $s
 ## output:
   ns_json:
    x/y.type: string
    x/y: z
    arr/0.type: number
    arr/0: 10
    arr/1.type: number
    arr/1: 20
[example_end]

Scan mode
[example_begin]
 ns_json parse -scan {{"a":1}{"b":2}}
 ## output: {{a 1} 7}
 
 # Parse the first JSON object and return the number of bytes consumed,
 # leaving a useful trailer (e.g., a checksum) after the JSON.
 set data {{"a":1} CRC32=0x3A5F2C19}
 set r [lb]ns_json parse -scan $data[rb]
 ## output: {{a 1} 7}
 
 # The consumed byte count lets you slice off the trailer:
 lassign $r d consumed
 set trailer [lb]string range {{"a":1} CRC32=0x3A5F2C19} $consumed end[rb]
 ## output: CRC32=0x3A5F2C19
[example_end]

Encode JSON strings safely
[example_begin]
 ns_json value -type string {a"b\c}
 ## output: "a\"b\\c"
[example_end]

Generate JSON from triples
[example_begin]
 ns_json value -type object {a int 1 b boolean 1 c string x n null __NS_JSON_NULL__}
 ## output: {"a":1,"b":true,"c":"x","n":null}
[example_end]

Key helpers for set output
[example_begin]
 ns_json keyencode {a.b}
 ## output: a~2b
 
 ns_json keyinfo {a~2b.type}
 ## output: key a.b field type
[example_end]

[see_also ns_set ns_base64 ns_cbor]
[keywords "global built-in" JSON WebAuthn encoding parsing]
[manpage_end]
